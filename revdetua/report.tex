\documentclass[mirror, portugues]{revdetua}
%
% Valid options are:
%   portugues --------- main language is Portuguese
%   final ------------- final version (default)
%   times ------------- use times (postscript) fonts for text
%   mirror ------------ prints a mirror image of the paper (with dvips)
%   visiblelabels ----- \SL, \SN, \SP, \EL, \EN, etc. defined
%   invisiblelabels --- \SL, \SN, \SP, \EL, \EN, etc. not defined (default)
%
% Note: the final version should use the times fonts
% Note: the really final version should also use the mirror option
%

\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath} 
\usepackage{comment}
\usepackage{algorithm}
\usepackage{algpseudocode}
\floatname{algorithm}{Algoritmo}
\usepackage{graphicx}
\usepackage[justification=centering]{caption}
\usepackage{float}
%-------------------------------------
% compiling:
% Recipe: xelatex
% Recipe: pdflatex -> bibtex -> pdflatex -> pdflatex
% Recipe: xelatex
%
% notas:
% rever se algorimtos e imagens estão onde devem
%-------------------------------------
\begin{document}

\Header{02}{3}{Dezembro}{2024}{1}

\title{Maximum Weight Cut Problem}
% MUDAR TITULO ALLEZ ALLEZ ALGO COM RANDOMIZADO
\author{Hugo Veríssimo - 124348 - hugoverissimo@ua.pt}
\maketitle

\begin{abstract}
... abstrato em ingles
\end{abstract}

\begin{resumo}
Este relatório apresenta a implementação e comparação de dois métodos para resolver o problema \textit{Maximum Weight Cut}: uma pesquisa exaustiva e uma heurística gulosa. O problema \textit{Maximum Weight Cut} con ESTE É O ANTIGO FAZER NOVO
\end{resumo}

\section{Introdução}

ja se analisou no outro relatorio a descrição do problema \textit{Maximum Weight Cut}, \cite{BS22} e ns q, super fixe

este relatoria visa explorar algoritmos com um certo grau de estocacidade/aletorieda com vista em otimizar a complexidade e as solucoes.

para alem disso os resultados são comparados aos obtidos anteriormente

serao entao implexmentados 3 algoritmos, nomeadamente: ... e ...

\section{Metodologia da Análise}

vamos usar o python por ter o modulo random e outros

ns q vamos usar os ficheiro tal e tal 

e para testar os algortimos serão testados os graficos do Gset e criados por nós com o ficheiro tal

Graphs for the Computational Experiments: mine and elearnig ou links and gset

\section{Algoritmo de 1}

- falar de como sao construidos: componente aletoria e determinisica ?

- Ensuring that no such solutions are tested more than once., como fiz isto

- quando é q o algortimo para?






\begin{algorithm}[H]
\raggedright
\textbf{Entrada:} SHDIASHDIUA \\
\textbf{Saída:} subconjuntos \textit{S} e \textit{T}, peso do corte \textit{weight} \\
\hrule 
\caption{NOME DO ALGORTIMO}
\begin{algorithmic}[1]
    \State \texttt{best\_solution} $\gets$ \texttt{None}
    \State \texttt{weight} $\gets$ 0
    \State \texttt{seen\_solutions} $\gets$ empty set
    \For{$i \gets 1$ \textbf{to} \texttt{solutions}}
        \State \texttt{partition} $\gets$ random partition of the nodes
        \If {\texttt{length}(\texttt{seen\_solutions}) $=$ $2^{\texttt{n\_nodes}}$}
            \State \textbf{break}
        \EndIf
        \State \texttt{partition\_hash} $\gets$ hash the partition
        \If {\texttt{partition\_hash} $\in$ \texttt{seen\_solutions}}
            \State \textbf{continue}
        \EndIf
        \State Add \texttt{partition\_hash} to \texttt{seen\_solutions}
        \State \texttt{new\_cut\_weight} $\gets$ compute the cut weight
        \If {\texttt{new\_cut\_weight} $>$ \texttt{weight}}
            \State \texttt{weight} $\gets$ \texttt{new\_cut\_weight}
            \State \texttt{best\_solution} $\gets$ copy of \texttt{partition}
        \EndIf
    \EndFor
    \State \texttt{S} $\gets$ set of nodes assigned to $0$ in \texttt{best\_solution}
    \State \texttt{T} $\gets$ set of nodes assigned to $1$ in \texttt{best\_solution}
    \Return \texttt{S}, \texttt{T}, \texttt{weight}
\end{algorithmic}
\end{algorithm}
    


- complexidade

\section{Algoritmo de 2}

dsadasd

\begin{algorithm}[H]
\raggedright
\textbf{Entrada:} matriz de adjacência \textit{G} \\
\textbf{Saída:} subconjuntos \textit{S} e \textit{T}, peso do corte \textit{weight} \\
\hrule 
\caption{Simulated Annealing for Graph Partitioning}
\begin{algorithmic}[1]

    \Require List of edges \texttt{edges}, number of nodes \texttt{n\_nodes}, initial temperature \texttt{initial\_temp}, cooling rate \texttt{cooling\_rate}, minimum temperature \texttt{min\_temp}
    \Ensure Partition sets \texttt{S} and \texttt{T}, and maximum cut weight \texttt{best\_cut}


    \While{\texttt{temperature} \ensuremath{>} \texttt{min\_temp}}
        \State \texttt{node} $\gets$ Randomly select a node from \texttt{nodes}
        \State Flip the partition of \texttt{node} in \texttt{partition}
        \State \texttt{new\_cut} $\gets$ Compute weight of edges crossing the new partition
        \State \texttt{cost\_diff} $\gets$ \texttt{new\_cut} $-$ \texttt{current\_cut}
        \If{\texttt{cost\_diff} \ensuremath{>} 0 \textbf{or} Random number \ensuremath{<} \ensuremath{\exp(\texttt{cost\_diff} / \texttt{temperature})}}
            \State Accept the move
            \State \texttt{current\_cut} $\gets$ \texttt{new\_cut}
            \If{\texttt{new\_cut} \ensuremath{>} \texttt{best\_cut}}
                \State \texttt{best\_cut} $\gets$ \texttt{new\_cut}
                \State \texttt{best\_partition} $\gets$ \texttt{partition}
            \EndIf
        \Else
            \State Reject the move \\
            \State and revert the partition change
        \EndIf
        
        
        \State \texttt{temperature} $\gets$ \texttt{temperature} \ensuremath{\times} \texttt{cooling\_rate}
    \EndWhile

    \State \texttt{nodes} $\gets$ \texttt{range(n\_nodes)}
    \State \texttt{partition} $\gets$ Random assignment of each node to $0$ or $1$
    \State \texttt{current\_cut} $\gets$ Compute weight of edges crossing the partition
    \State \texttt{temperature} $\gets$ \texttt{initial\_temp}
    \State \texttt{best\_partition} $\gets$ \texttt{partition}
    \State \texttt{best\_cut} $\gets$ \texttt{current\_cut}

    \State \texttt{S} $\gets$ Set of nodes assigned to $0$ in \texttt{best\_partition}
    \State \texttt{T} $\gets$ Set of nodes assigned to $1$ in \texttt{best\_partition}
    \Return \texttt{S}, \texttt{T}, \texttt{best\_cut}
\end{algorithmic}
\end{algorithm}

    

...

- complexidade

- falar de como sao construidos: componente aletoria e determinisica ?

- Ensuring that no such solutions are tested more than once., como fiz isto

- quando é q o algortimo para?


\section{Algoritmo de 3}

...

\begin{algorithm}[H]
\raggedright
\textbf{Entrada:} matriz de adjacência \textit{G} \\
\textbf{Saída:} subconjuntos \textit{S} e \textit{T}, peso do corte \textit{weight} \\
\hrule 
\caption{Random Greedy Optimization for Max Weight Cut}
\begin{algorithmic}[1]
    \Require List of edges \texttt{edges}, number of nodes \texttt{n\_nodes}, iteration limit factor \texttt{itLim}
    \Ensure Partition sets \texttt{S} and \texttt{T}, and maximum cut weight \texttt{cut\_weight}

    \State \texttt{partition} $\gets$ Random assignment of each node to $0$ or $1$
    \State \texttt{cut\_weight} $\gets$ Compute weight of edges crossing the partition
    \State \texttt{improved} $\gets$ \texttt{True}
    \State \texttt{it\_limit} $\gets$ \texttt{len(edges)} \ensuremath{\times} \texttt{itLim}

    \While{\texttt{improved} \textbf{and} \texttt{it\_limit} \ensuremath{>} 0}
        \State \texttt{it\_limit} $\gets$ \texttt{it\_limit} $- 1$
        \State \texttt{improved} $\gets$ \texttt{False}
        \For{\texttt{node} \textbf{in} \texttt{range(n\_nodes)}}
            \State Flip the partition of \texttt{node}
            \State \texttt{new\_cut\_weight} $\gets$ Compute weight of edges crossing the partition
            \If{\texttt{new\_cut\_weight} \ensuremath{>} \texttt{cut\_weight}}
                \State \texttt{cut\_weight} $\gets$ \texttt{new\_cut\_weight}
                \State \texttt{improved} $\gets$ \texttt{True}
                \State \textbf{break}  \Comment{Stop iteration for this node}
            \Else
                \State Revert the partition of \texttt{node}
            \EndIf
        \EndFor
    \EndWhile

    \State \texttt{S} $\gets$ Set of nodes assigned to $0$ in \texttt{partition}
    \State \texttt{T} $\gets$ Set of nodes assigned to $1$ in \texttt{partition}
    \Return \texttt{S}, \texttt{T}, \texttt{cut\_weight}
\end{algorithmic}
\end{algorithm}
    

- complexidade

- falar de como sao construidos: componente aletoria e determinisica ?

- Ensuring that no such solutions are tested more than once., como fiz isto

- quando é q o algortimo para?

\section{Análise dos Resultados}

Compare the results of the experimental and the formal analysis.

todos os grafos devem ser corridos pelo menos 5 vezes, e a media dos resultados deve ser calculada e mediana do tempo , por causa dos tempos e da aleatoriedade dos resultados

Graphs for the Computational Experiments: mine and elearnig and gset

asdasds

\subsection{(1) the number of basic operations carried out}

dsadasds

\subsection{2 the execution time }

- Determine the largest graph that you can process on your computer, without taking too much time.

- Estimate the execution time that would be required by much larger problem instances.

dsadasd

\subsection{solution}

asdad

\subsubsection{(3) the number of solutions / configurations tested}

sadsad

\subsubsection{precision}

asdasd



\bibliography{refs}

\end{document}
